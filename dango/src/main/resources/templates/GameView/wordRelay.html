<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> 끝말 잇기 게임 </title>
  <style>
    #result-box { /* 게임결과 창 */
      display: none; /* 처음에는 숨김 */
      margin-top: 20px;
      font-size: 18px;
      color: blue;
    }
  </style>
</head>
<body>

<div id="chat-box">
  <!-- GPT 첫 메시지: 페이지 로드 시 자동으로 추가 -->
</div>

<div>
  <input type="text" id="user-input" placeholder="단어를 입력하세요" />
  <button id="send-btn">보내기</button>
</div>

<!-- 게임 결과를 보여주는 박스 -->
<div id="result-box">
  <h2>게임 결과</h2>
  <p id="result-message"></p>
  <button id="restart-btn" style="display:none;">게임 다시 시작</button>
</div>

<script>
  let chatHistory = []; // 대화 기록 저장소 (ArrayList처럼 사용)
  let userTimeout;
  let gptWordCount = 0; // GPT가 응답한 횟수를 추적하는 변수 (이것이 점수가 됨)
  let userWordCount = 0; // 사용자가 입력한 단어 수를 추적하는 변수
  let userId = 1;  // 사용자의 고유 ID (서버에서 전달)

  // 페이지가 로드되면 바로 GPT에게 첫 번째 단어 요청
  window.onload = async function() {
    await startGame(); // 페이지 로드 시 /start API 호출
  }

  // 첫 번째 메시지 : 게임 시작
  async function startGame() {
    try {
      let response = await fetch('/game/wordRelay/start');  // /start 엔드포인트 호출
      let firstWord = await response.text();  // GPT의 첫 단어 응답 받음
      addMessage('GPT', firstWord);  // GPT의 첫 단어를 화면에 추가
      startUserTimer(); // 사용자 응답 대기 시작
    } catch (error) {
      console.error('Error during startGame:', error);  // 에러 처리
      endGame("게임을 시작할 수 없습니다. 오류 발생.", gptWordCount);
    }
  }

  // 대화 기록에 메시지 추가 (ArrayList에 저장)
  function addMessage(sender, message) {
    chatHistory.push({ sender, message });
    let messageDiv = document.createElement('div');
    messageDiv.textContent = sender === 'user' ? `사용자: ${message}` : `GPT: ${message}`;
    document.getElementById('chat-box').appendChild(messageDiv);
  }

  // 사용자 타이머 시작 (10초)
  function startUserTimer() {
    clearTimeout(userTimeout);
    userTimeout = setTimeout(() => {
      endGame("사용자가 10초 안에 응답하지 못했습니다. 게임 종료.", gptWordCount);
    }, 10000);
  }

  // 끝말을 잇지 못하는 경우 검사 (GPT의 마지막 단어와 비교)
  function isValidWord(word) {
    // GPT가 마지막에 말한 단어만 비교
    let lastGPTWord = chatHistory.length > 0 && chatHistory[chatHistory.length - 1].sender === 'GPT'
            ? chatHistory[chatHistory.length - 1].message
            : '';

    if (!lastGPTWord) return true; // GPT가 아직 말하지 않았다면 첫 단어는 무조건 통과

    // GPT의 마지막 글자와 사용자의 첫 글자 비교
    let lastCharOfGPTWord = lastGPTWord.charAt(lastGPTWord.length - 1);
    let firstCharOfUserWord = word.charAt(0);

    return lastCharOfGPTWord === firstCharOfUserWord;
  }

  // 사용자가 단어를 반복해서 말했는지 검사
  function isRepeatedWord(word) {
    return chatHistory.some(entry => entry.message === word);
  }

  // 게임 종료 시 다시 시작 버튼 표시
  function endGame(message, score) {
    document.getElementById('user-input').disabled = true;
    document.getElementById('send-btn').disabled = true;
    clearTimeout(userTimeout);

    // 결과 메시지 설정 및 화면에 표시
    document.getElementById('result-message').textContent = `${message} 사용자 점수: ${score}`;
    document.getElementById('result-box').style.display = 'block';

    // 게임 결과 서버로 전송
    processGameResult(userId, score);

    // 게임 다시 시작 버튼 보이기
    document.getElementById('restart-btn').style.display = 'block';
  }

  // 게임 결과를 서버에 보내는 함수
  async function processGameResult(userId, gameScore) {
    try {
      let response = await fetch('/game/wordRelay/result', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: new URLSearchParams({
          userId: userId,
          gameScore: gameScore
        })
      });

      let result = await response.text();
      console.log(result);  // 서버 응답 메시지 확인
    } catch (error) {
      console.error('Error during processGameResult:', error);
    }
  }


  // 게임 결과를 서버에 보내는 함수
  async function processGameResult(userId, gameScore) {
    try {
      let response = await fetch('/game/wordRelay/result', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: new URLSearchParams({
          userId: userId,
          gameScore: gameScore
        })
      });

      let result = await response.text();
      console.log(result);  // 서버 응답 메시지 확인
    } catch (error) {
      console.error('Error during processGameResult:', error);
    }
  }

  // 사용자가 단어를 입력하고 보내는 기능
  document.getElementById('send-btn').addEventListener('click', async () => {
    let userWord = document.getElementById('user-input').value.trim();
    if (!userWord) return;

    // 이미 나온 단어인지 확인
    if (isRepeatedWord(userWord)) {
      endGame("같은 단어를 반복했습니다. 게임 종료.", gptWordCount);
      return;
    }

    clearTimeout(userTimeout); // 사용자 타이머 해제
    addMessage('user', userWord);
    userWordCount++; // 사용자가 입력한 단어 수 증가

    // 한 글자 단어 처리
    if (userWord.length === 1) {
      endGame("한 글자 단어를 입력했습니다. 게임 종료.", gptWordCount);
      return;
    }

    // 끝말 잇기 실패 처리 (GPT의 마지막 단어와 비교)
    if (!isValidWord(userWord)) {
      endGame("끝말을 잇지 못했습니다. 게임 종료.", gptWordCount);
      return;
    }

    // GPT에게 단어 전달
    try {
      let response = await fetch(`/game/wordRelay/relay?word=${userWord}`);
      let gptWord = await response.text();
      addMessage('GPT', gptWord);

      // GPT가 응답을 성공적으로 했으면 점수 증가
      gptWordCount++;  // GPT가 단어를 응답했으므로 점수 증가

      // GPT가 "
      if (gptWord.includes("YOU")) {
        endGame(gptWord, gptWordCount - 1);  // GPT가 이겼을 때 점수는 GPT 응답 횟수
      } else if (gptWord.includes("YOU WIN")) {
        endGame(gptWord, gptWordCount + 500);  // GPT가 졌을 때는 +500점 추가
      } else {
        startUserTimer(); // 끝말잇기가 계속되면 다시 사용자 타이머 시작
      }

    } catch (error) {
      endGame("GPT가 응답하지 못했습니다. 게임 종료.", gptWordCount);
    }

    document.getElementById('user-input').value = ''; // 입력 필드 초기화
  });

</script>

</body>
</html>
